import { __decorate } from "tslib";
import { Component, Input, Output, EventEmitter, OnChanges, ElementRef, ChangeDetectionStrategy, SimpleChanges } from '@angular/core';
import { trigger, style, animate, transition } from '@angular/animations';
import { select } from 'd3-selection';
import * as ɵngcc0 from '@angular/core';

var _c0 = ["ngx-charts-line", ""];
var LineComponent = /** @class */ (function () {
    function LineComponent(element) {
        this.element = element;
        this.fill = 'none';
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
    }
    LineComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.initialized = true;
            this.initialPath = this.path;
        }
        else {
            this.updatePathEl();
        }
    };
    LineComponent.prototype.updatePathEl = function () {
        var node = select(this.element.nativeElement).select('.line');
        if (this.animations) {
            node.transition().duration(750).attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    LineComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input()
    ], LineComponent.prototype, "path", void 0);
    __decorate([
        Input()
    ], LineComponent.prototype, "stroke", void 0);
    __decorate([
        Input()
    ], LineComponent.prototype, "data", void 0);
    __decorate([
        Input()
    ], LineComponent.prototype, "fill", void 0);
    __decorate([
        Input()
    ], LineComponent.prototype, "animations", void 0);
    __decorate([
        Output()
    ], LineComponent.prototype, "select", void 0);
LineComponent.ɵfac = function LineComponent_Factory(t) { return new (t || LineComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
LineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineComponent, selectors: [["g", "ngx-charts-line", ""]], inputs: { fill: "fill", animations: "animations", path: "path", stroke: "stroke", data: "data" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 1, vars: 4, consts: [["stroke-width", "1.5px", 1, "line"]], template: function LineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@animationState", "active");
        ɵngcc0.ɵɵattribute("d", ctx.initialPath)("fill", ctx.fill)("stroke", ctx.stroke);
    } }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        strokeDasharray: 2000,
                        strokeDashoffset: 2000
                    }),
                    animate(1000, style({
                        strokeDashoffset: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line]',
                template: "\n    <svg:path\n      [@animationState]=\"'active'\"\n      class=\"line\"\n      [attr.d]=\"initialPath\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      stroke-width=\"1.5px\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                strokeDasharray: 2000,
                                strokeDashoffset: 2000
                            }),
                            animate(1000, style({
                                strokeDashoffset: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { fill: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], path: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return LineComponent;
}());
export { LineComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluZS5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIkBzd2ltbGFuZS9uZ3gtY2hhcnRzL2xpYi9saW5lLWNoYXJ0L2xpbmUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFNBQVMsRUFDVCxVQUFVLEVBQ1YsdUJBQXVCLEVBQ3ZCLGFBQWEsRUFDZCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDMUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGNBQWMsQ0FBQzs7OztBQWdDdEM7QUFBaUQsSUFZL0MsdUJBQW9CLE9BQW1CO0FBQUksUUFBdkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtBQUFDLFFBUi9CLFNBQUksR0FBVyxNQUFNLENBQUM7QUFDakMsUUFBVyxlQUFVLEdBQVksSUFBSSxDQUFDO0FBQ3RDLFFBQ1ksV0FBTSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7QUFDeEMsUUFDRSxnQkFBVyxHQUFZLEtBQUssQ0FBQztBQUMvQixJQUU0QyxDQUFDO0FBQzdDLElBQ0UsbUNBQVcsR0FBWCxVQUFZLE9BQXNCO0FBQUksUUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDM0IsWUFBTSxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztBQUM5QixZQUFNLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNuQyxTQUFLO0FBQUMsYUFBSztBQUNYLFlBQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQzFCLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFFSCxJQUFFLG9DQUFZLEdBQVo7QUFBYyxRQUNaLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwRSxRQUNJLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtBQUN6QixZQUFNLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0QsU0FBSztBQUFDLGFBQUs7QUFDWCxZQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQyxTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0Y7QUFDd0QsZ0JBckIxQixVQUFVO0FBQUc7QUFFckMsSUFiSTtBQUNKLFFBREosS0FBSyxFQUFFO0FBQUMsK0NBQUs7QUFDZixJQUFVO0FBQ04sUUFERixLQUFLLEVBQUU7QUFBQyxpREFBTztBQUNqQixJQUFVO0FBQ0osUUFESixLQUFLLEVBQUU7QUFBQywrQ0FBSztBQUNmLElBQVU7QUFBYSxRQUFyQixLQUFLLEVBQUU7QUFBQywrQ0FBc0I7QUFDaEMsSUFBVTtBQUFhLFFBQXJCLEtBQUssRUFBRTtBQUFDLHFEQUEyQjtBQUV0QyxJQUFZO0FBQWEsUUFBdEIsTUFBTSxFQUFFO0FBQUMsaURBQTRCO0lBUDNCLGFBQWEsd0JBOUJ6QixTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUUsb0JBQW9CLGNBQzlCLFFBQVEsRUFBRTtnTUFTVCxjQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNLGNBQy9DLFVBQVUsRUFBRSxrQkFDVixPQUFPLENBQUMsZ0JBQWdCLEVBQUUsc0JBQ3hCLFVBQVUsQ0FBQyxRQUFRLEVBQUUsMEJBQ25CLEtBQUssQ0FBQztBQUNKLGVBQWUsRUFBRSxJQUFJO2tCQUNyQixnQkFBZ0IsRUFBRTtBQUFJO01BQ3ZCLENBQUMsMEJBQ0YsT0FBTyxDQUNMLElBQUksRUFDSixLQUFLLENBQUM7MkJBQ0osZ0JBQWdCLEVBQUUsQ0FBQywwQkFDcEIsQ0FBQyxDQUNIO01BQ0YsQ0FBQyxrQkFDSCxDQUFDLGNBQ0g7RUFDRixDQUFDLFFBQ1csYUFBYSxDQWdDekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUNEO0FBQUMsSUFERCxvQkFBQztBQUNBLENBREEsQUFoQ0QsSUFnQ0M7QUFDRCxTQWpDYSxhQUFhO0FBQUkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgT25DaGFuZ2VzLFxuICBFbGVtZW50UmVmLFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0eWxlLCBhbmltYXRlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtbGluZV0nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6cGF0aFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XCInYWN0aXZlJ1wiXG4gICAgICBjbGFzcz1cImxpbmVcIlxuICAgICAgW2F0dHIuZF09XCJpbml0aWFsUGF0aFwiXG4gICAgICBbYXR0ci5maWxsXT1cImZpbGxcIlxuICAgICAgW2F0dHIuc3Ryb2tlXT1cInN0cm9rZVwiXG4gICAgICBzdHJva2Utd2lkdGg9XCIxLjVweFwiXG4gICAgLz5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogMjAwMCxcbiAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiAyMDAwXG4gICAgICAgIH0pLFxuICAgICAgICBhbmltYXRlKFxuICAgICAgICAgIDEwMDAsXG4gICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogMFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgXSlcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBMaW5lQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgQElucHV0KCkgcGF0aDtcbiAgQElucHV0KCkgc3Ryb2tlO1xuICBASW5wdXQoKSBkYXRhO1xuICBASW5wdXQoKSBmaWxsOiBzdHJpbmcgPSAnbm9uZSc7XG4gIEBJbnB1dCgpIGFuaW1hdGlvbnM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgaW5pdGlhbFBhdGg6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHt9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxQYXRoID0gdGhpcy5wYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhdGhFbCgpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVBhdGhFbCgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KS5zZWxlY3QoJy5saW5lJyk7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25zKSB7XG4gICAgICBub2RlLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApLmF0dHIoJ2QnLCB0aGlzLnBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmF0dHIoJ2QnLCB0aGlzLnBhdGgpO1xuICAgIH1cbiAgfVxufVxuIl19