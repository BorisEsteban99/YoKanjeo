import { Component, forwardRef, NgZone, ElementRef, Input, Output, ViewChild, EventEmitter, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';

var _c0 = ["textarea"];
var defaults = {
    contentsCss: [''],
    customConfig: ''
};
var CKEditorComponent = /** @class */ (function () {
    function CKEditorComponent(ngZone, hostEl) {
        this.ngZone = ngZone;
        this.hostEl = hostEl;
        this.innerValue = '';
        this.disabled = false;
        this.editorInitialized = false;
        /**
         * Is readonly mode, default:false
         */
        this.readonly = false;
        /**
         * The ck-editor config object.
         */
        this.config = {};
        /**
         * The special skin, default: moono-lisa
         */
        this.skin = 'moono-lisa';
        /**
         * The special language, default: en
         */
        this.language = 'en';
        /**
         * Use fullpage mode, default:false
         */
        this.fullPage = false;
        /**
         * Use inline mode, default: false
         */
        this.inline = false;
        this.change = new EventEmitter();
        this.ready = new EventEmitter();
        this.blur = new EventEmitter();
        this.focus = new EventEmitter();
        this.onChange = (/**
         * @param {?} value
         * @return {?}
         */
        function (value) { });
        this.onTouched = (/**
         * @return {?}
         */
        function () { });
        this.identifier = CKEditorComponent.getRandomIdentifier(this.id);
    }
    /**
     * @private
     * @param {?=} id
     * @return {?}
     */
    CKEditorComponent.getRandomIdentifier = /**
     * @private
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id === void 0) { id = ''; }
        return 'editor-' + (id !== '' ? id : String(CKEditorComponent.idx++));
    };
    Object.defineProperty(CKEditorComponent.prototype, "instance", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ckIns;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} changes
     * @return {?}
     */
    CKEditorComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (this.editorInitialized) {
            this.destroyEditor();
            this.initEditor(this.identifier);
        }
    };
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        if (!this.editorInitialized && this.documentContains(this.textareaRef.nativeElement)) {
            this.editorInitialized = true;
            this.initEditor(this.identifier);
        }
        else if (this.editorInitialized && !this.documentContains(this.textareaRef.nativeElement)) {
            this.editorInitialized = false;
            this.destroyEditor();
        }
    };
    /**
     * @return {?}
     */
    CKEditorComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyEditor();
    };
    /**
     * @private
     * @param {?} identifier
     * @return {?}
     */
    CKEditorComponent.prototype.initEditor = /**
     * @private
     * @param {?} identifier
     * @return {?}
     */
    function (identifier) {
        var _this = this;
        if (typeof CKEDITOR === 'undefined') {
            return console.warn('CKEditor 4.x is missing (http://ckeditor.com/)');
        }
        /** @type {?} */
        var textareaEl = this.textareaRef.nativeElement;
        this.identifier = identifier;
        textareaEl.setAttribute('name', this.identifier);
        if (this.ckIns || !this.documentContains(this.textareaRef.nativeElement)) {
            return;
        }
        /** @type {?} */
        var opt = Object.assign({}, defaults, this.config, {
            readOnly: this.readonly,
            skin: this.skin,
            language: this.language,
            fullPage: this.fullPage,
            inline: this.inline
        });
        this.ckIns = this.inline ? CKEDITOR.inline(textareaEl, opt) : CKEDITOR.replace(textareaEl, opt);
        this.ckIns.setData(this.innerValue);
        this.ckIns.on('change', (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var val = _this.ckIns.getData();
            _this.updateValue(val);
        }));
        this.ckIns.on('instanceReady', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            _this.ngZone.run((/**
             * @return {?}
             */
            function () {
                _this.ready.emit(evt);
            }));
        }));
        this.ckIns.on('blur', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            _this.ngZone.run((/**
             * @return {?}
             */
            function () {
                _this.blur.emit(evt);
                _this.onTouched();
            }));
        }));
        this.ckIns.on('focus', (/**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            _this.ngZone.run((/**
             * @return {?}
             */
            function () {
                _this.focus.emit(evt);
            }));
        }));
    };
    /**
     * @private
     * @return {?}
     */
    CKEditorComponent.prototype.destroyEditor = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.ckIns) {
            // If use destroy, will fire 'Error code: editor-destroy-iframe'
            // this.ckIns.destroy();
            if (CKEDITOR.instances.hasOwnProperty(this.ckIns.name)) {
                CKEDITOR.remove(CKEDITOR.instances[this.ckIns.name]);
            }
            this.ckIns = null;
            /** @type {?} */
            var editorEl = this.hostEl.nativeElement.querySelector('#cke_' + this.identifier);
            if (editorEl != null && editorEl.parentElement) {
                editorEl.parentElement.removeChild(editorEl);
            }
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    CKEditorComponent.prototype.updateValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.ngZone.run((/**
         * @return {?}
         */
        function () {
            _this.innerValue = value;
            _this.onChange(value);
            _this.onTouched();
            _this.change.emit(value);
        }));
    };
    /**
     * @private
     * @param {?} node
     * @return {?}
     */
    CKEditorComponent.prototype.documentContains = /**
     * @private
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return document.contains ? document.contains(node) : document.body.contains(node);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    CKEditorComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.innerValue = value || '';
        if (this.ckIns) {
            // Fix bug that can't emit change event when set non-html tag value twice in fullpage mode.
            this.ckIns.setData(this.innerValue);
            /** @type {?} */
            var val = this.ckIns.getData();
            this.ckIns.setData(val);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CKEditorComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CKEditorComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    CKEditorComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    CKEditorComponent.idx = 1;
    /** @nocollapse */
    CKEditorComponent.ctorParameters = function () { return [
        { type: NgZone },
        { type: ElementRef }
    ]; };
    CKEditorComponent.propDecorators = {
        readonly: [{ type: Input }],
        config: [{ type: Input }],
        skin: [{ type: Input }],
        language: [{ type: Input }],
        fullPage: [{ type: Input }],
        inline: [{ type: Input }],
        id: [{ type: Input }],
        change: [{ type: Output }],
        ready: [{ type: Output }],
        blur: [{ type: Output }],
        focus: [{ type: Output }],
        textareaRef: [{ type: ViewChild, args: ['textarea', { static: false },] }]
    };
CKEditorComponent.ɵfac = function CKEditorComponent_Factory(t) { return new (t || CKEditorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
CKEditorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CKEditorComponent, selectors: [["ck-editor"]], viewQuery: function CKEditorComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textareaRef = _t.first);
    } }, inputs: { readonly: "readonly", config: "config", skin: "skin", language: "language", fullPage: "fullPage", inline: "inline", id: "id" }, outputs: { change: "change", ready: "ready", blur: "blur", focus: "focus" }, exportAs: ["ckEditor"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(( /**
                         * @return {?}
                         */function () { return CKEditorComponent; })), multi: true }]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 0, consts: [["textarea", ""]], template: function CKEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "textarea", null, 0);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CKEditorComponent, [{
        type: Component,
        args: [{
                selector: 'ck-editor',
                template: "\n    <textarea #textarea></textarea>\n  ",
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(( /**
                                 * @return {?}
                                 */function () { return CKEditorComponent; })), multi: true }],
                exportAs: 'ckEditor'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }]; }, { readonly: [{
            type: Input
        }], config: [{
            type: Input
        }], skin: [{
            type: Input
        }], language: [{
            type: Input
        }], fullPage: [{
            type: Input
        }], inline: [{
            type: Input
        }], change: [{
            type: Output
        }], ready: [{
            type: Output
        }], blur: [{
            type: Output
        }], focus: [{
            type: Output
        }], id: [{
            type: Input
        }], textareaRef: [{
            type: ViewChild,
            args: ['textarea', { static: false }]
        }] }); })();
    return CKEditorComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var CKEditorModule = /** @class */ (function () {
    function CKEditorModule() {
    }
CKEditorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CKEditorModule });
CKEditorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CKEditorModule_Factory(t) { return new (t || CKEditorModule)(); }, providers: [], imports: [[], FormsModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CKEditorModule, { declarations: function () { return [CKEditorComponent]; }, exports: function () { return [FormsModule, CKEditorComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CKEditorModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [FormsModule, CKEditorComponent],
                declarations: [CKEditorComponent],
                providers: []
            }]
    }], function () { return []; }, null); })();
    return CKEditorModule;
}());

export { CKEditorComponent, CKEditorModule };

//# sourceMappingURL=ngx-ckeditor.js.map